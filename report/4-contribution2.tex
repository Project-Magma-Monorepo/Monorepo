\section{Contribution 2: Generic Package-Based Indexer}

Our second contribution offers an alternative approach to data indexing on Sui through a so-called generic, package-focused indexer. This implementation, found in the \texttt{sui\_indexer\_checkpointTx} repository, provides a streamlined solution that automatically processes all transactions related to a specific package without requiring deep technical knowledge of the Sui framework. Unlike the modular SDK (sui-indexer-modular), this solution does not allow the developer to choose the database type or customize the data extraction.

\subsection{Design Philosophy}

The generic indexer is built on a fundamentally different philosophy compared to the modular SDK:

\begin{itemize}
    \item \textbf{Simplicity First:} Minimize configuration and coding requirements to make indexing accessible to all teams.
    \item \textbf{Package-Focused:} Automatically capture all data related to a specific smart contract package.
    \item \textbf{Containerized Deployment:} Provide ready-to-use Docker configuration for easy deployment.
    \item \textbf{Local and Remote Modes:} Support both local checkpoint processing and remote checkpoint fetching.
\end{itemize}

This approach is designed for teams that need quick access to their on-chain data without investing significant resources in understanding the Sui framework or building custom indexing solutions.

\subsection{Technical Implementation}

\subsubsection{Architecture Overview}

The generic indexer is implemented as a lightweight Rust application with Docker support. Its architecture consists of these key components:

\begin{itemize}
    \item \textbf{GenericIndexer:} A template-based implementation that can work with any data type.
    \item \textbf{GenericPipeline:} A processing pipeline that automatically filters transactions by package.
    \item \textbf{FieldCallback:} A generalized callback system that works with any data structure.
    \item \textbf{Docker Integration:} Pre-configured Docker and Docker Compose setup for turnkey deployment.
\end{itemize}

\subsubsection{Key Implementation Features}

The generic indexer offers several notable technical features:

\begin{enumerate}
    \item \textbf{Type-Generic Implementation:} The core indexer is implemented as a generic Rust type, allowing it to work with any data structure that implements the required traits:

    \begin{verbatim}
    pub struct GenericIndexer<T> {
        package_filter: Option<SuiAddress>,
        field_filters: Vec<IndexField>,
        field_callbacks: HashMap<IndexField, FieldCallback<T>>,
        indexer: Option<IndexerCluster>,
    }
    \end{verbatim}

    \item \textbf{Simplified Package Filtering:} The indexer automatically filters transactions that interact with the specified package address:

    \begin{verbatim}
    fn check_package(&self, package_id: &ObjectID) -> bool {
        package_id.to_string() == self.package_filter.to_string()
    }
    \end{verbatim}

    \item \textbf{Flexible Environment Configuration:} The indexer can be configured entirely through environment variables:

    \begin{verbatim}
    PACKAGE_ADDRESS=0x123...def
    REMOTE_STORE_URL=https://fullnode.mainnet.sui.io:443
    START_CHECKPOINT=0
    LOCAL_MODE=false
    \end{verbatim}
\end{enumerate}

\subsection{Deployment and Usage}

One of the key advantages of the generic indexer is its streamlined deployment process:

\begin{enumerate}
    \item \textbf{Configuration:} Set a few environment variables to specify the package to index and data source.
    \item \textbf{Deployment:} Run a single Docker Compose command to start the indexer and database.
    \item \textbf{Data Access:} Connect to the PostgreSQL database to query indexed data.
\end{enumerate}

The Docker-based deployment strategy eliminates the need for complex setup procedures and ensures consistent behavior across different environments.

\subsubsection{Local vs. Remote Mode}

The generic indexer supports two distinct operational modes:

\begin{itemize}
    \item \textbf{Remote Mode:} Connects to a Sui Full Node to fetch checkpoint data, suitable for indexing live data.
    \item \textbf{Local Mode:} Processes checkpoint files stored locally, ideal for historical data analysis or airgapped environments.
\end{itemize}

This flexibility allows teams to choose the most appropriate mode for their specific requirements.

\subsection{Data Model and Storage}

Unlike the modular SDK, which provides a predefined database schema, the generic indexer takes a more flexible approach:

\begin{itemize}
    \item \textbf{Customizable Data Storage:} Teams can define their own data structures for storing indexed information.
    \item \textbf{Framework Agnostic:} The indexer does not impose any specific database schema.
    \item \textbf{JSON-Based Storage:} Complex data structures are typically stored as JSON for maximum flexibility.
\end{itemize}

This approach sacrifices some of the structure provided by the modular SDK in favor of greater flexibility and simplicity.

\subsection{Use Case Example: DeFi Protocol Analytics}

To illustrate the practical application of the generic indexer, consider a DeFi protocol that needs to track all transactions interacting with their smart contracts.

Using the generic indexer, the implementation would:

\begin{enumerate}
    \item Set the PACKAGE\_ADDRESS environment variable to the protocol's package address
    \item Run docker-compose up to start the indexer
    \item Connect a visualization tool like Appsmith to the PostgreSQL database
    \item Create dashboards showing transaction volume, unique users, and other metrics
\end{enumerate}

This entire process could be completed in minutes rather than days or weeks, without requiring any Rust programming knowledge or deep understanding of the Sui framework.

\subsection{Advantages for Non-Technical Teams}

The generic indexer offers particular advantages for teams with limited technical resources:

\begin{itemize}
    \item \textbf{Zero Code Configuration:} No programming is required beyond basic environment variable configuration.
    \item \textbf{Turnkey Deployment:} Docker-based deployment eliminates complex setup procedures.
    \item \textbf{Full Data Sovereignty:} Teams maintain complete control over their data without relying on third-party services.
    \item \textbf{Minimal Maintenance:} The containerized solution requires minimal ongoing maintenance.
    \item \textbf{Extensibility:} Advanced users can still customize the indexing process if needed.
\end{itemize}

These advantages make the generic indexer an ideal solution for teams that want to focus on their core business logic rather than infrastructure development.

\subsection{Limitations and Future Work}

While the generic indexer excels at simplicity, it does have some limitations:

\begin{itemize}
    \item \textbf{Limited Customization:} Less flexibility compared to the modular SDK approach.
    \item \textbf{Less Structured Data:} Without a predefined schema, data analysis may require more effort.
    \item \textbf{Resource Efficiency:} May process more data than strictly necessary for some use cases.
\end{itemize}

Future work could address these limitations through:

\begin{itemize}
    \item Adding configurable data transformation options
    \item Implementing schema templates for common use cases
    \item Optimizing data storage for specific analytics scenarios
    \item Integrating with popular visualization tools and services
\end{itemize} 